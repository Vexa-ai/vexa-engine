# Transcription Processing Migration Plan

## Overview
Moving transcription processing from @engine to @dashboard while simplifying the architecture by removing Redis and mutable/immutable states. Transcript-speaker matching will be moved to @audio service.

## Key Decisions

1. Data Flow Changes:
   - Remove Redis layer completely
   - Direct database storage from audio service transcriptions
   - Transcript-speaker matching moved to @audio service
   - Remove separate diarization process

2. Timestamp Handling:
   - Single timestamp approach in output data
   - Audio service provides segment timestamps internally
   - Final API/database only exposes start_timestamp
   - Maintain chronological ordering of transcripts

3. Content Processing:
   - Keep HTML formatting and short version fields in schema
   - Defer implementation of HTML formatting for later stages
   - Maintain content_html and content_html_short in database structure

4. Speaker Information:
   - Transcript-speaker matching done in @audio service
   - Each transcript comes with pre-matched speaker info
   - No speaker processing needed in dashboard/engine

## Implementation Phases

### Phase 1 - Audio Service Refactoring
1. Code Changes:
   - Remove diarization-related code
   - Update transcription processor to include speaker matching
   - Modify segment output format to include matched speakers
   - Update API endpoints to reflect new data structure

2. Test Cases:
   - Unit Tests:
     - Test speaker matching accuracy
     - Verify timestamp handling
     - Validate segment format
   - Integration Tests:
     - End-to-end transcription flow
     - Audio processing pipeline
     - API response format
   - Performance Tests:
     - Processing time benchmarks
     - Memory usage monitoring

### Phase 2 - Dashboard Database Setup
1. Code Changes:
   - Implement transcript database schema
   - Create database migrations
   - Set up basic DAL layer
   - Add database health checks

2. Test Cases:
   - Unit Tests:
     - DAL operations (CRUD)
     - Schema validations
     - Timestamp handling
   - Integration Tests:
     - Migration scripts
     - Database connections
     - Transaction handling
   - Performance Tests:
     - Query performance
     - Index effectiveness

### Phase 3 - Dashboard Integration
1. Code Changes:
   - Create audio service client
   - Implement transcript processor
   - Set up API endpoints
   - Add error handling and retries

2. Test Cases:
   - Unit Tests:
     - Client methods
     - Error handling
     - Retry logic
   - Integration Tests:
     - Audio service communication
     - End-to-end transcript flow
     - Error recovery scenarios
   - Performance Tests:
     - Response times
     - Concurrent requests
     - Resource usage

### Phase 4 - Migration & Cleanup
1. Code Changes:
   - Remove Redis dependencies
   - Clean up old code paths
   - Update documentation
   - Add monitoring

2. Test Cases:
   - Migration Tests:
     - Data consistency checks
     - No data loss validation
     - Rollback procedures
   - System Tests:
     - Full system functionality
     - Performance comparison
     - Resource usage validation

## Database Schema

```sql
CREATE TABLE transcripts (
    id UUID PRIMARY KEY,
    meeting_id VARCHAR NOT NULL,
    content TEXT NOT NULL,
    content_html TEXT,
    content_html_short TEXT,
    start_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    speaker VARCHAR,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

## API Endpoints

1. Audio Service (New):
```python
GET /v1/segments/transcripts
Response:
{
    "meeting_id": str,
    "segments": [
        {
            "content": str,
            "speaker": str,
            "start_timestamp": datetime,
            "confidence": float
        }
    ]
}
```

2. Dashboard Service:
```python
GET /api/v1/transcripts
Query Parameters:
- meeting_id: str
- last_timestamp: datetime (optional)
- limit: int (optional)

POST /api/v1/transcripts
Body:
{
    "meeting_id": str,
    "content": str,
    "speaker": str,
    "start_timestamp": datetime
}
```

## Next Steps

1. Begin Audio Service Refactoring:
   - Remove diarization code
   - Update processor class
   - Add speaker matching
   - Write initial tests

2. Start Dashboard Setup:
   - Create database migrations
   - Set up basic DAL
   - Implement test framework
