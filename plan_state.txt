# Content Management System - Current State and Migration Plan

## 1. Current State Analysis

### 1.1 Core Components

1. **Content Management**
   - SQLAlchemy models in `app/models/psql_models.py`
   - Content types: meetings, documents, notes
   - Parent-child relationships
   - Entity associations

2. **LLM Core** (root level)
   - `llm_core.py` (core LLM functionality)
   - `prompts.py` (prompt management)
   - `pydantic_models.py` (LLM models)

3. **Services Structure**
   ```
   app/services/
   ├── analytics/
   │   ├── api.py
   │   ├── export.py
   │   ├── init_db.py
   │   └── models.py
   ├── auth/
   │   └── tokens.py
   ├── chat/
   │   ├── chat.py
   │   └── manager.py
   ├── content/
   │   ├── access.py
   │   ├── manager.py
   │   ├── notes.py
   │   ├── notes_api.py
   │   ├── processor.py
   │   └── sharing.py
   ├── indexing/
   │   ├── content_relations.py
   │   ├── decorators.py
   │   ├── models.py
   │   ├── monitor.py
   │   ├── processor.py
   │   ├── redis/
   │   │   ├── keys.py
   │   │   └── monitor.py
   │   └── worker.py
   └── search/
       ├── elastic.py
       ├── hybrid.py
       └── qdrant.py
   ```

4. **API Structure**
   ```
   app/api/
   ├── v1/
   │   ├── analytics.py
   │   ├── auth.py
   │   ├── content.py
   │   ├── entities.py
   │   ├── chat.py
   │   └── share.py
   └── deps.py
   ```

## 2. Content API Endpoints Plan

### 2.1 Pydantic Models

```python
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime
from uuid import UUID
from enum import Enum

class ContentType(str, Enum):
    MEETING = 'meeting'
    DOCUMENT = 'document'
    TITLE = 'title'
    SUMMARY = 'summary'
    NOTE = 'note'

class EntityRef(BaseModel):
    name: str
    type: str

class ContentFilter(BaseModel):
    content_type: Optional[ContentType] = None
    entity_type: Optional[str] = None
    entity_names: Optional[List[str]] = None
    parent_id: Optional[UUID] = None
    date_from: Optional[datetime] = None
    date_to: Optional[datetime] = None

class ContentListRequest(BaseModel):
    filter: Optional[ContentFilter] = None
    limit: int = Field(default=20, ge=1, le=100)
    offset: int = Field(default=0, ge=0)

class ContentCreate(BaseModel):
    type: ContentType
    text: str
    parent_id: Optional[UUID] = None
    entities: Optional[List[EntityRef]] = None

class ContentUpdate(BaseModel):
    text: Optional[str] = None
    entities: Optional[List[EntityRef]] = None

class ContentResponse(BaseModel):
    content_id: UUID
    type: ContentType
    text: str
    timestamp: datetime
    parent_id: Optional[UUID]
    entities: List[EntityRef]
    is_indexed: bool
    metadata: dict
```

### 2.2 API Endpoints

1. **List Contents**
   ```
   GET /api/v1/contents
   Query Parameters:
   - type: Optional[ContentType]
   - entity_type: Optional[str]
   - entity_names: Optional[List[str]]
   - parent_id: Optional[UUID]
   - limit: int = 20
   - offset: int = 0
   - date_from: Optional[datetime]
   - date_to: Optional[datetime]
   ```

2. **Create Content**
   ```
   POST /api/v1/contents
   Body: ContentCreate
   Notes: 
   - Cannot create MEETING type
   - Parent ID must be validated
   - Entity references must exist
   ```

3. **Update Content**
   ```
   PUT /api/v1/contents/{content_id}
   Body: ContentUpdate
   Notes:
   - Cannot update MEETING type
   - Entity references must exist
   ```

4. **Archive/Restore Content**
   ```
   POST /api/v1/contents/{content_id}/archive
   POST /api/v1/contents/{content_id}/restore
   Notes:
   - Soft delete implementation
   - Keep relationships intact
   ```

5. **Content Indexing**
   ```
   POST /api/v1/contents/{content_id}/index
   GET /api/v1/contents/{content_id}/index
   Notes:
   - Check indexing status
   - Queue for indexing
   ```

6. **Get Content Details**
   ```
   GET /api/v1/contents/{content_id}
   Query Parameters:
   - include_parent: bool = False
   Notes:
   - Include metadata based on type
   - Handle meeting transcripts differently
   ```

### 2.3 Implementation Notes

1. **Access Control**
   - Check user permissions for each operation
   - Handle shared content access
   - Maintain ownership information

2. **Validation Rules**
   - Content type restrictions
   - Entity reference validation
   - Parent-child relationship validation
   - Date range validation

3. **Error Handling**
   - Clear error messages
   - Proper HTTP status codes
   - Validation error responses

4. **Performance**
   - Pagination for lists
   - Efficient entity filtering
   - Caching where appropriate

## 3. Migration Goals

### 3.1 Primary Objectives

1. **Clean Architecture**
   - Clear separation of concerns
   - Logical module organization
   - Consistent naming conventions

2. **Maintainability**
   - Centralized SQLAlchemy models
   - Isolated LLM functionality
   - Organized test suite

3. **Minimal Disruption**
   - Keep core functionality intact
   - Preserve existing APIs
   - Maintain backward compatibility

### 3.2 Non-Goals

1. **Avoid Over-engineering**
   - No unnecessary abstractions
   - Keep related code together
   - Maintain simple imports

2. **Preserve Working Systems**
   - Keep LLM core in root
   - Maintain API client location
   - Keep SQLAlchemy models unified

## 4. New Project Structure

### 4.1 Root Level
```
/
├── llm_core.py          # Core LLM functionality
├── prompts.py           # LLM prompts
├── pydantic_models.py   # LLM models
├── api_client.py        # Testing client
├── app.py              # FastAPI application
├── alembic.ini         # Database migrations
└── requirements.txt    # Dependencies
```

### 4.2 Application Structure
```
app/
├── api/                 # API routes
│   ├── v1/
│   │   ├── content.py
│   │   ├── entities.py
│   │   ├── chat.py     # Renamed from threads.py
│   │   ├── auth.py
│   │   └── share.py
│   └── deps.py
│
├── models/
│   ├── psql_models.py  # All SQLAlchemy models
│   └── schema/         # API Pydantic models
│
├── services/
│   ├── content/
│   ├── entity/
│   ├── chat/          # Renamed from thread/
│   ├── search/
│   └── indexing/
│
├── core/
│   ├── config.py
│   └── security.py
│
└── utils/
    ├── db.py
    └── redis.py
```

### 4.3 Test Organization
```
tests/
├── api/
├── chat/
├── content/
└── search/
```

## 5. Migration Plan

### 5.1 Files to Move

1. **Database Related**
   - `psql_models.py` → `app/models/psql_models.py`
   - `psql_helpers.py` → `app/utils/db.py`
   - `psql_notes.py` → `app/services/content/notes.py`
   - `psql_sharing.py` → `app/services/content/sharing.py`
   - `psql_access.py` → `app/services/content/access.py`

2. **Search Related**
   - `qdrant_search.py` → `app/services/search/qdrant.py`
   - `bm25_search.py` → `app/services/search/elastic.py`
   - `hybrid_search.py` → `app/services/search/hybrid.py`

3. **Chat & Auth**
   - `thread_manager.py` → `app/services/chat/manager.py`
   - `chat.py` → `app/services/chat/chat.py`
   - `token_manager.py` → `app/services/auth/tokens.py`

### 5.2 Files to Keep in Root

1. **LLM Core**
   - `core.py` → Rename to `llm_core.py`
   - `prompts.py`
   - `pydantic_models.py`

2. **API & Testing**
   - `api_client.py`

3. **Configuration**
   - `app.py`
   - `alembic.ini`
   - `requirements.txt`
   - Setup scripts
   - `Dockerfile`

### 5.3 Implementation Phases

1. **Phase 1: Test Organization**
   - Create test directory structure
   - Move test files
   - Update imports
   - Verify all tests pass

2. **Phase 2: Core Models**
   - Move database models
   - Update imports
   - Test functionality

3. **Phase 3: Services**
   - Rename thread to chat
   - Move service files
   - Update imports
   - Test each service

4. **Phase 4: Cleanup**
   - Update documentation
   - Remove unused imports
   - Final testing

## 6. Migration Guidelines

### 6.1 Code Movement Rules

1. **File Moves**
   - Copy file to new location
   - Update imports
   - Test functionality
   - Remove old file

2. **Import Updates**
   - Use relative imports in app
   - Keep root imports absolute
   - Update dependent files

### 6.2 Testing Strategy

1. **Test Suite**
   - Organize by feature
   - Maintain existing tests
   - Add missing coverage

2. **Verification**
   - Run tests after each move
   - Check API functionality
   - Verify LLM operations

### 6.3 Rollback Plan

1. **Backup**
   - Git branches
   - Documented changes
   - Revert scripts

2. **Verification Points**
   - After each phase
   - Before major changes
   - After import updates
